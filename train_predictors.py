#!/usr/bin/env python3
"""
Training script for sparsity predictors using datasets generated by generate_dataset.py.

This script trains predictors to identify which MLP neurons will be most activated
based on the hidden states before each MLP layer. Uses the last token representations
from the generated datasets.

Usage:
    python train_predictors.py \
        --config meta-llama/Llama-2-7b-hf \
        --dataset_dir ./data/c4 \
        --output_dir ./trained_predictors \
        --layer_idx 0 \
        --batch_size 32 \
        --num_epochs 10 \
        --learning_rate 1e-5
"""

import argparse
import logging
import time

import torch

from transformers import AutoConfig
import wandb

from transformers.trainer_utils import set_seed

from src.predictor_trainer import LayerwisePredictorTrainer, StreamingSparsityDataset

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)



def main():
    parser = argparse.ArgumentParser(description="Train sparsity predictors from pre-generated datasets")
    parser.add_argument("--config", type=str, required=True, help="Path to model config file")
    parser.add_argument("--dataset_dir", type=str, required=True, help="Directory containing dataset.csv and arrays/")
    parser.add_argument("--output_dir", type=str, required=True, help="Output directory for trained models")
    parser.add_argument("--layer_idx", type=int, required=True, help="Which layer to train predictor for")
    parser.add_argument("--batch_size", type=int, default=64, help="Training batch size")
    parser.add_argument("--num_epochs", type=int, default=10, help="Number of training epochs")
    parser.add_argument("--learning_rate", type=float, default=1e-5, help="Learning rate")
    parser.add_argument("--lora_size", type=int, default=None, help="LoRA bottleneck size (default: 4% of intermediate_size)")
    parser.add_argument("--val_split", type=float, default=0.2, help="Validation split fraction")
    parser.add_argument("--cache_size", type=int, default=50, help="Number of .npz chunk files to cache in memory")
    parser.add_argument("--seed", type=int, default=42, help="Random seed")
    parser.add_argument("--use_wandb", action="store_true", help="Use Weights & Biases logging")
    parser.add_argument("--wandb_project", type=str, default="llama-skip-predictors", help="W&B project name")
    parser.add_argument("--wandb_entity", type=str, default="llama-skip-predictors", help="W&B entity name")
    parser.add_argument("--device", type=str, default="auto", help="Device to use (auto, cpu, cuda)")

    
    args = parser.parse_args()
    
    # Set seed
    set_seed(args.seed)
    
    # Setup device
    if args.device == "auto":
        device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    else:
        device = torch.device(args.device)
    
    logger.info(f"Using device: {device}")
    
    # Load config
    config = AutoConfig.from_pretrained(args.config)
    
    # Calculate LoRA size if not provided
    if args.lora_size is None:
        lora_size = int(config.intermediate_size * 0.04)  # 4% of intermediate size
    else:
        lora_size = args.lora_size
    
    logger.info(f"Model config: hidden_size={config.hidden_size}, intermediate_size={config.intermediate_size}")
    logger.info(f"Training predictor for layer {args.layer_idx} with LoRA size {lora_size}")
    
    # Initialize wandb
    if args.use_wandb:
        wandb.init(
            entity=args.wandb_entity,
            project=args.wandb_project,
            config=vars(args),
            name=f"predictor-layer-{args.layer_idx}-training-{int(time.time())}"
        )

    # Initialize trainer
    trainer = LayerwisePredictorTrainer(
        layer_idx=args.layer_idx,
        hidden_size=config.hidden_size, 
        intermediate_size=config.intermediate_size, 
        lora_size=lora_size, 
        device=device
    )
    
    # Load streaming datasets
    logger.info(f"Loading streaming dataset for layer {args.layer_idx}")
    full_dataset = StreamingSparsityDataset(args.dataset_dir, args.layer_idx, cache_size=args.cache_size)
    
    # Create train/validation split
    total_samples = len(full_dataset)
    val_size = int(total_samples * args.val_split)
    train_size = total_samples - val_size
    
    # Use torch's random_split for the streaming dataset
    train_dataset, val_dataset = torch.utils.data.random_split(
        full_dataset, [train_size, val_size], 
        generator=torch.Generator().manual_seed(args.seed)
    )
    
    logger.info(f"Using {len(train_dataset)} training samples, {len(val_dataset)} validation samples")
    
    # Train predictor
    trainer.train_layer(
        train_dataset=train_dataset,
        val_dataset=val_dataset,
        num_epochs=args.num_epochs,
        batch_size=args.batch_size,
        learning_rate=args.learning_rate,
        use_wandb=args.use_wandb
    )
            
    # Save predictor
    trainer.save_predictor(args.output_dir, name=f"predictor_layer_{args.layer_idx}")
    
    if args.use_wandb:
        wandb.finish()
    
    logger.info("Training completed!")


if __name__ == "__main__":
    main() 